<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>组管理和权限管理 Linux</title>
      <link href="2021/050726398.html"/>
      <url>2021/050726398.html</url>
      
        <content type="html"><![CDATA[<h2 id="组基本介绍"><a href="#组基本介绍" class="headerlink" title="组基本介绍"></a>组基本介绍</h2><p>在Linux中的每个用户都必须属于一个组，<strong>不能独立于组外</strong>。在Linux中<strong>每个文件</strong>有所有者、所在组、其他组的概念。</p><ol><li>所有者</li><li>所在组</li><li>其他组</li><li>改变用户所在组</li></ol><h3 id="文件-目录-修改所有者-所在组"><a href="#文件-目录-修改所有者-所在组" class="headerlink" title="文件/目录 修改所有者 所在组"></a>文件/目录 修改所有者 所在组</h3><p>一般为文件的创建者，谁创建了该文件，就自然称为该文件的所有者</p><ul><li>查看文件的所有者：ls -ahl<br><img src="https://img-blog.csdnimg.cn/20210426123222131.png"><br>mokapeng是该文件的所有者，root是该文件的所在组，apple.txt是文件名</li><li>修改文件所有者：chown 用户名 文件名</li><li>修改文件所在组：chgrp 组名 文件名</li></ul><h3 id="组的创建"><a href="#组的创建" class="headerlink" title="组的创建"></a>组的创建</h3><p>基本指令：groupadd 组名<br>eg:实例<br>1）创建一个组，monster：groupadd monster<br>2）创建一个用户fox，并放入到monster中：useradd -g monster fox</p><h3 id="改变用户所在组"><a href="#改变用户所在组" class="headerlink" title="改变用户所在组"></a>改变用户所在组</h3><p>在添加用户时，可以指定该用户添加到哪个组，同样的用root的管理权限也可改变某个用户所在组。</p><ul><li>改变用户所在组<br>usermod -g 新组名 用户名     (改变用户所在组)<br>usermod -d 目录名 用户名   (改变用户登录的初始目录,注意:用户要有进入新目录的权限)<br>eg:将apple这个用户从原来的组修改到fruit组：usermod -g fruit apple</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据类型 Java</title>
      <link href="2021/050748647.html"/>
      <url>2021/050748647.html</url>
      
        <content type="html"><![CDATA[<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><img src="https://img-blog.csdnimg.cn/20210430153349546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNjk2NTE4,size_16,color_FFFFFF,t_70"></p><blockquote><p><strong>注意：C/C++中char占1个字节。但Java中编码是Unicode16，所以一个char占2个字节</strong></p></blockquote><h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><p>Java的整数类型就是用于存放整数的，如1，12，39等<br>类型     | 占用存储空间    | 范围<br>——– | —–    | ——<br>byte [字节]  | 1字节    |-128 ~ 127<br>short [短整型]  | 2字节    | -2^15 ~ 2^15-1<br>int [整型]  |  4字节    | 4字节 | -2^31 ~ 2^31-1<br>long [长整型]     | 8字节| -2^63 ~ 2^63-1</p><ol><li>Java各整数类型有固定的范围和字段长度，不受OS不同的影响</li><li>Java的整型常量默认为int，要声明long型常量须后加’l’或’L’</li><li>bit：计算机中的最小存储单位。byte：计算机中基本存储单位，1byte=8bit</li></ol><h3 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h3><p>Java的浮点类型可以表示一个小数，如123.4</p><table><thead><tr><th>类型</th><th>占用存储空间</th><th>范围</th></tr></thead><tbody><tr><td>单精度float</td><td>4字节</td><td>-3.403E38 ~ 3.403E38</td></tr><tr><td>双精度double</td><td>8字节</td><td>-1.798E308 ~ 1.798E308</td></tr></tbody></table><ol><li>关于浮点数在机器中存放形式：浮点数=符号位+指数位+尾数为</li><li>尾数部分可能丢失，造成精度损失(小数都是近似值)</li><li>Java的浮点型常量默认为double，声明float要加’f’ 或 ‘F’</li><li>浮点陷阱：double num=8.1 / 3 ≠ 2.7 所以当对<strong>运算结果为小数</strong>时，尽量不要进行相等判断，应该是两数差值在一定范围内就认为相等</li></ol><h3 id="字符类型-char"><a href="#字符类型-char" class="headerlink" title="字符类型(char)"></a>字符类型(char)</h3><p>字符类型可以表示单个字符，字符类型是char，占两个字节(可存汉字)多个字符可以用字符串String存储</p><pre class=" language-java"><code class="language-java"><span class="token keyword">char</span> c1<span class="token operator">=</span><span class="token string">'a'</span><span class="token punctuation">;</span><span class="token keyword">char</span> c2<span class="token operator">=</span><span class="token string">'\t'</span><span class="token punctuation">;</span><span class="token keyword">char</span> c3<span class="token operator">=</span><span class="token string">'哈'</span><span class="token punctuation">;</span><span class="token keyword">char</span> c4<span class="token operator">=</span><span class="token number">97</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//说明字符类型可直接存放一个数字，但在输出时是Unicode码对应的字符</span></code></pre><p>使用细节：</p><ol><li>字符常量使用单引号</li><li>Java还允许使用转义字符’'来将其后的字符变成特殊字符型常量。eg’\n’</li><li>在java中char的本质是一个整数，在输出时是Unicode码对应的字符</li><li>char类型是可以进行运算的，相当于一个整数<blockquote><p>字符类型存储到计算机中，是存储字符对应的码值(整数)<br>eg：’a’ –&gt;码值97 –&gt; 二进制 –&gt;存储</p></blockquote></li></ol><p>字符编码表详解：</p><ul><li>ASCII：一个字节表示，一共表示128个字符，实际最多可表示256，但只用到128个，缺点就是表示字符过少</li><li>Unicode：固定大小的编码，使用两个字节表示字符，字符和汉字统一占用2个字节，浪费空间。<br>优点：将世界所有符号都纳入其中(2的16次方)，使用Unicode不会有乱码问题，且Unicode兼容ASCII码<br>缺点：一个字母或汉字都占2个字符，太浪费空间</li><li>utf-8：大小可变的编码，字母使用1字符，汉字使用3个字节。是互联网使用最广泛的一种Unicode的改进方式。最大优势就是可变长编码。</li><li>gbk：可以表示汉字，且范围广，字母使用1个字节，汉字使用2个</li><li>gb2312：可表示汉字，gb2312&lt;gbk</li><li>big5：繁体中文，台湾，香港</li></ul><h3 id="布尔类型boolean"><a href="#布尔类型boolean" class="headerlink" title="布尔类型boolean"></a>布尔类型boolean</h3><ol><li>布尔类型也叫boolean类型，只允许取值true，false，null</li><li>boolean类型占1个字符</li><li>boolean类型不可用非0之类的代表true或false</li></ol><h2 id="基本数据类型转换"><a href="#基本数据类型转换" class="headerlink" title="基本数据类型转换"></a>基本数据类型转换</h2><p>当java程序进行赋值或运算时，精度小的类型可以自动转换为精度大的数据类型，这就是<strong>自动类型转换</strong><br>char –&gt; int –&gt; long –&gt;float –&gt; double<br>byte –&gt; short –&gt; int –&gt;long –&gt; float –&gt; double<br>自动类型转换注意的细节：</p><ol><li>有多种数据类型混合运算时，系统会先自动转换成精度最大的那种数据类型，然后再计算</li><li>(byte、short)和char之间不会相互自动转换</li><li><strong>byte、short、char三者之间或各自单独都可以计算，但会首先转为int类型</strong>，也就是byte+byte或byte+short都会变为int</li><li>boolean不参与转换<pre class=" language-java"><code class="language-java"><span class="token keyword">float</span> n1 <span class="token operator">=</span> <span class="token number">5</span> <span class="token operator">+</span> <span class="token number">1.1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//报错，1.1默认为double，float精度小于double不可转换</span><span class="token keyword">byte</span> b1<span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//正确，会先判断该数是否再byte范围内，如果在就正确</span><span class="token keyword">short</span> s1<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">short</span> s2 <span class="token operator">=</span> b1 <span class="token operator">+</span> s1<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//报错，byte,short,char混合运算会转为int，而int精度高于short</span><span class="token keyword">byte</span> b2 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">byte</span> b3 <span class="token operator">=</span> b1 <span class="token operator">+</span> b2<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//报错，byte+byte也会先转为int，int精度高于byte</span></code></pre></li></ol><h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><p>自动类型转换的逆过程，将精度高的转为精度低的。使用时要加上强制转换符()，但可能造成精度损失或溢出。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> n1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token number">1.9</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>n1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1  精度损失</span><span class="token keyword">byte</span> b1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span><span class="token number">2000</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>b1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// -48 数据溢出</span></code></pre><p>强值转换使用细节：</p><ol><li>强制转换符号只针对最近的操作符<pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token number">10</span><span class="token operator">*</span><span class="token number">3.5</span><span class="token operator">+</span><span class="token number">6</span><span class="token operator">*</span><span class="token number">1.5</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 报错，这强制转换只针对10，所以运算总体仍未double类型</span></code></pre></li><li>char类型可以保存int的常量值，但不能保存int变量值，需要强转</li><li> <strong>byte、short、char三者之间或各自单独都可以计算，但会首先转为int类型</strong>，也就是byte+byte或byte+short都会变为int</li></ol><h2 id="基本数据类型和String类型的转换"><a href="#基本数据类型和String类型的转换" class="headerlink" title="基本数据类型和String类型的转换"></a>基本数据类型和String类型的转换</h2><h3 id="基本数据类型转为String类型"><a href="#基本数据类型转为String类型" class="headerlink" title="基本数据类型转为String类型"></a>基本数据类型转为String类型</h3><p>语法：将基本类型的值+””即可</p><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> n1 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>String s1 <span class="token operator">=</span> n1 <span class="token operator">+</span> <span class="token string">""</span><span class="token punctuation">;</span></code></pre><h3 id="String类型转为基本数据类型"><a href="#String类型转为基本数据类型" class="headerlink" title="String类型转为基本数据类型"></a>String类型转为基本数据类型</h3><p>语法：通过基本数据类型的包装类调用parseXXX方法即可</p><pre class=" language-java"><code class="language-java">String s1 <span class="token operator">=</span> <span class="token string">"123"</span><span class="token punctuation">;</span><span class="token keyword">int</span> n1 <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">double</span> d1 <span class="token operator">=</span> Double<span class="token punctuation">.</span><span class="token function">parseDouble</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>特殊：字符串转为char，eg：得到字符串第一个字符</p><pre class=" language-java"><code class="language-java">String s <span class="token operator">=</span> <span class="token string">"123"</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>字符串转为基本数据类型时，要是格式不匹配会直接报异常！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>定时任务crond&amp;at Linux</title>
      <link href="2021/050720359.html"/>
      <url>2021/050720359.html</url>
      
        <content type="html"><![CDATA[<p>Linux定时执行任务有两种一种是周而复始类，反复执行(crond)，一种是定时执行一次任务(at)</p><h2 id="crond"><a href="#crond" class="headerlink" title="crond"></a>crond</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>crontab 进行定时任务的设置<br>任务调度：指系统在某个时间执行特定的命令或程序<br>调度分类：</p><ol><li>系统工作：有些系统工作必须周而复始地执行。如病毒扫描等</li><li>个别用户工作：个别用户可能希望执行某些程序，如对mysql备份<br><img src="https://img-blog.csdnimg.cn/20210428134925842.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNjk2NTE4,size_16,color_FFFFFF,t_70"></li></ol><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>crontab [选项]<br>常用选项：<br>-e：编辑crontab定时任务<br>-l：查询crontab任务<br>-r：删除当前用户所有crontab任务</p><h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><p>设置任务调度文件：/etc/crontab<br>设置个人任务调度。执行crontab -e<br>接着输入任务到调度文件<br>eg:*/1 * * * * ls -l /etc/ &gt; /tmp/to.txt  (注意空格；即每小时的每分钟执行一次ls -l /etc/ &gt; /tmp/to.txt )</p><h4 id="参数细节说明"><a href="#参数细节说明" class="headerlink" title="参数细节说明"></a>参数细节说明</h4><p>5个占位符的说明<br><img src="https://img-blog.csdnimg.cn/2021042813293985.png"><br>特殊符号说明<br><img src="https://img-blog.csdnimg.cn/20210428133657351.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNjk2NTE4,size_16,color_FFFFFF,t_70"><br>特定时间执行任务案例<br><img src="https://img-blog.csdnimg.cn/20210428133823350.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNjk2NTE4,size_16,color_FFFFFF,t_70"></p><h4 id="crond任务调度实例"><a href="#crond任务调度实例" class="headerlink" title="crond任务调度实例"></a>crond任务调度实例</h4><p>1）：每隔1分钟，就将当前日期信息，追加到/tmp/mydate文件中<br>*/1 * * * * date &gt;&gt; /tmp/mydate<br>2）：每隔1分钟，就将当前日期和日历都追加到/home/mycal中<br>方法1：crontab -e  然后写两条指令即可<br>方法2：先写个脚本，然后定时执行该脚本</p><ol><li>vim /home/my.sh 写入内容：date &gt;&gt; /home/mycal和cal &gt;&gt; /home/mycal</li><li>给my.sh添加执行权限</li><li>crond -e 增加 */1 * * * * /home/my.sh</li></ol><h3 id="crond相关指令"><a href="#crond相关指令" class="headerlink" title="crond相关指令"></a>crond相关指令</h3><ul><li>crontab -r：终止任务调度</li><li>crontab -l：列出所有那些任务调度</li><li>service crond restart：重启任务调度</li></ul><h2 id="at"><a href="#at" class="headerlink" title="at"></a>at</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>at命令是一次性定时计划任务，at的守护进程atd会以后台模式运行，检查作业队列来运行</li><li>默认情况下，atd守护进程(运行在后台的特殊进程)每60秒检查作业队列，有作业时，会检查作业运行时间，如果时间与当前时间匹配，则运行此作业</li><li>at命令是一次性定时计划任务，执行完一个任务后不再执行此任务</li><li>在使用at命令的时候，一定要保证atd进程的启动，可以使用相关指令来查看<br>(可用ps -ef grep | ‘atd’ 检查atd是否在运行)<br><img src="https://img-blog.csdnimg.cn/20210502165654628.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNjk2NTE4,size_16,color_FFFFFF,t_70"></li></ol><h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><p>at [选项] [时间]<br>Ctrl+D  结束at命令输入，要输入两次才有反应<br>atq  查看系统中有没有执行的工作任务<br>atrm 编号       删除已经设置的任务</p><h4 id="at命令选项："><a href="#at命令选项：" class="headerlink" title="at命令选项："></a>at命令选项：</h4><p><img src="https://img-blog.csdnimg.cn/20210502162320547.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNjk2NTE4,size_16,color_FFFFFF,t_70"></p><h4 id="at时间定义"><a href="#at时间定义" class="headerlink" title="at时间定义"></a>at时间定义</h4><p>at指定时间的方法：</p><ol><li>接受当天的hh:mm（小时:分钟）式的时间指定。假如该时间已过，则放在第二天执行</li><li>使用midnight(深夜)，noon(中午)，teatime(一般为下午4点)等比较模糊的词语来指定时间</li><li>采用12小时计时制，即在时间后面加上AM或PM说明上下午</li><li>指定命名执行的具体日期，指定格式为month day(月 日)或mm/dd/yy(月/日/年)或dd.mm.yy(日.月.年)，指定的日期必须跟在指定的时间后面。eg 04:00 2021-03-01</li><li>使用相对计时法。指定格式为：now + count time-units，now就是当前时间，time-unites为时间单位(minutes、hours、days、weeks)，count是时间数量。eg：now + 5 minutes</li><li>直接today、tomorrow来指定完成命令时间</li></ol><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>1）2天后的下午5点执行 /bin/ls /home<br><img src="https://img-blog.csdnimg.cn/20210502163903878.png"><br>2）明天17点钟，输出时间到指定文件内 比如/root/date1.log<br><img src="https://img-blog.csdnimg.cn/20210502164818432.png"><br>3）删除已经设置的任务，atrm 编号 eg：atrm 1</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> crond </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM、JDK、JER介绍</title>
      <link href="2021/050625004.html"/>
      <url>2021/050625004.html</url>
      
        <content type="html"><![CDATA[<h2 id="JVM-Java-virtue-machine"><a href="#JVM-Java-virtue-machine" class="headerlink" title="JVM(Java virtue machine)"></a>JVM(Java virtue machine)</h2><p>1）JVM是一个虚拟计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据、内存、寄存器，<strong>包含在JDK中</strong><br>2） 对于不同的平台，有不同的虚拟机。<br>3）Java 虚拟机机制屏蔽了底层运行平台的差别，实现了“一次编译，到处运行”<br><img src="https://img-blog.csdnimg.cn/20210430110848950.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNjk2NTE4,size_16,color_FFFFFF,t_70"></p><h2 id="JDK介绍"><a href="#JDK介绍" class="headerlink" title="JDK介绍"></a>JDK介绍</h2><ol><li>JDK(Java Development Kit Java 开发工具包) JDK=JRE+java的开发工具[java,javac,javadoc,javap等]</li><li>JDK是提供给Java开发人员使用的，其中包含java的开发工具，也包括JRE。所有安装了JDK就不用单独安装JRE</li></ol><h2 id="JRE介绍"><a href="#JRE介绍" class="headerlink" title="JRE介绍"></a>JRE介绍</h2><ol><li>JRE(Java Runtime Environment   java运行环境)  JRE=JVM+Java核心类库</li><li>包括Java虚拟机(JVM Java Virtual Machine)和java程序所需要的核心类库。如果想要运行一个开发好的Java程序，只需要安装JRE即可</li></ol><h2 id="JVM、JDK、JRE包含关系"><a href="#JVM、JDK、JRE包含关系" class="headerlink" title="JVM、JDK、JRE包含关系"></a>JVM、JDK、JRE包含关系</h2><ol><li>JDK = JRE + 开发工具集（例如 Javac,java 编译工具等)</li><li>JRE = JVM + Java SE 标准类库（java 核心类库）</li><li>如果只想运行开发好的 .class 文件 只需要 JR</li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>发表博客步骤及一些细节</title>
      <link href="2021/050652308.html"/>
      <url>2021/050652308.html</url>
      
        <content type="html"><![CDATA[<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>在博客目录下Git Bash –&gt;  hexo new “文章名字” </li><li>完成第一步后，会在\source\_posts目录下生成一个对于的md文件</li><li>在md文件中编写博客</li><li>完成后 hexo clean –&gt; hexo g –&gt;hexo s(预览一下) –&gt;hexo d (上传部署)</li><li>要删除该博文只需要去_post下删除对于的markdown博文即可</li></ol><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><ol><li>要想生成目录，不用在md文件编写时加上，这样解析不出来，要在最开始将设置toc: true，这样就会部署之后会自动生成目录</li><li>目录结构从## ，不要从# 开始，这样目录解析不出来</li><li>目录之间空一行，这样才能点击跳到指定位置</li><li>发表有图片的博客时，要想在图片在本地很麻烦，直接用网络地址</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件/目录权限 Linux</title>
      <link href="2021/050617999.html"/>
      <url>2021/050617999.html</url>
      
        <content type="html"><![CDATA[<h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p><img src="https://img-blog.csdnimg.cn/20210426125945693.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNjk2NTE4,size_16,color_FFFFFF,t_70" alt="1"></p><h2 id="rwx详解"><a href="#rwx详解" class="headerlink" title="rwx详解"></a>rwx详解</h2><h3 id="rwx作用到文件"><a href="#rwx作用到文件" class="headerlink" title="rwx作用到文件"></a>rwx作用到文件</h3><ol><li>[ r ]：代表可读(read)：可以读取，查看</li><li>[ w ]：代表可写(write)：可修改，但不代表可以删除该文件，删除一个文件的前提是对该目录也拥有写权限</li><li>[ x ]：代表可执行(execute)：可以被执行</li></ol><h3 id="rwx作用到目录"><a href="#rwx作用到目录" class="headerlink" title="rwx作用到目录"></a>rwx作用到目录</h3><ol><li>[ r ]：代表可读(read)：可以读取，ls查看目录内容</li><li>[ w ]：代表可写(write)：可修改，对目录内创建+删除+重命名目录</li><li>[ x ]：代表可执行(execute)：可以进入该目录</li></ol><h2 id="修改权限-chmod"><a href="#修改权限-chmod" class="headerlink" title="修改权限 -chmod"></a>修改权限 -chmod</h2><p>可以修改文件或目录的权限</p><ul><li>第一种方式：+、-、= 变更权限<br>u：所有者 g：所在组  o：其他人 a：所有人<br>1）chmod u=rwx,g=rx,o=x 文件/目录名<br>2）chmod o+w 文件/目录名<br>3）chmod a-x 文件/目录名<br>实例：<br>1）给abc文件的所有者 读写执行 的权限，给所在组 读执行 权限，给其他组 读执行 权限<br>chmod u=rwx,g=rx,o=rx abc<br>2）给abc文件所有者除去执行权限，增加所在组写的权限<br>chmod u-x,g+w abc<br>3）给abc文件所有用户添加读权限<br>chmod a+r abc</li><li>第二种方式：通过数字变更权限<br>r=4，w=2，x=1  rwx=7<br>chmod u=rwx,g=rx,o=x 文件/目录名；相当于chmod 751 文件/目录名</li></ul><h2 id="修改文件-目录所有者-chown"><a href="#修改文件-目录所有者-chown" class="headerlink" title="修改文件/目录所有者 chown"></a>修改文件/目录所有者 chown</h2><p>chown newowner 文件/目录名   (改变所有者)<br>chown newowner:newgroup 文件/目录名 (改变所有者，所在组)<br>-R(大写)：如果是一个目录 则使其下所有子文件或目录递归生效<br>eg：将/home/kkk 目录下所有文件和目录的所有者都修改成tom<br>chown -R  tom /home/kkk</p><h1 id="修改文件-目录所在组-chgrp"><a href="#修改文件-目录所在组-chgrp" class="headerlink" title="修改文件/目录所在组 chgrp"></a>修改文件/目录所在组 chgrp</h1><p>chgrp newgroup 文件/目录 (改变所有组)<br>-R(大写)：如果是一个目录 则使其下所有子文件或目录递归生效<br>eg：将 /home/kkk目录下的所有文件和目录的所在组都修改成mokapeng<br>chgrp -R  mokapeng /home/kkk</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
